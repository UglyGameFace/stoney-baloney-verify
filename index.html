<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stoney Baloney Verify</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Glitch&family=Fredoka:wght@400;600&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

    <style>
        :root {
            --neon-green: #39ff14;
            --neon-red: #ff3333;
            --neon-orange: #ffaa00;
            --neon-purple: #bc13fe;
            --deep-space: #050505;
            --grid-color: rgba(57, 255, 20, 0.15);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--deep-space); color: #fff; font-family: 'Fredoka', sans-serif;
            min-height: 100dvh; display: flex; flex-direction: column; overflow: hidden; position: relative; touch-action: none;
        }

        /* --- VISUAL FX --- */
        .trippy-bg { position: fixed; top: 0; left: 0; width: 200%; height: 200%; background: radial-gradient(circle, #1a0b2e 10%, #000000 90%); z-index: -3; animation: breathe 10s infinite alternate; }
        .grid-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(var(--grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--grid-color) 1px, transparent 1px); background-size: 40px 40px; perspective: 500px; z-index: -2; opacity: 0.5; mask-image: radial-gradient(circle, black 40%, transparent 80%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 999; }

        /* --- LAYOUT --- */
        .app-container { flex: 1; display: flex; flex-direction: column; width: 100%; max-width: 500px; margin: 0 auto; padding: 15px; z-index: 10; position: relative; }
        .header { text-align: center; margin-bottom: 20px; margin-top: 10px; }
        .logo-icon { font-size: 60px; color: var(--neon-green); filter: drop-shadow(0 0 15px var(--neon-green)); animation: float 3s ease-in-out infinite; }
        .brand-name { font-family: 'Rubik Glitch', cursive; font-size: 38px; color: #fff; text-shadow: 2px 2px 0px var(--neon-purple); margin-top: 5px; line-height: 1; }
        .chill-text { color: #ccc; font-size: 13px; margin-top: 8px; font-family: 'Share Tech Mono', monospace; letter-spacing: 1px; }

        /* --- SCREENS --- */
        .screen { display: none; flex-direction: column; flex: 1; height: 100%; }
        .screen.active { display: flex; animation: fade-in 0.4s ease; }
        @keyframes fade-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes breathe { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }

        /* --- SELECT SCREEN --- */
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
        .option { background: rgba(0,0,0,0.4); border: 2px solid #333; border-radius: 10px; padding: 25px 10px; text-align: center; transition: 0.2s; }
        .option:active { border-color: var(--neon-green); background: rgba(57, 255, 20, 0.15); box-shadow: 0 0 15px var(--neon-green); }
        .option i { font-size: 32px; color: #fff; margin-bottom: 10px; }
        .card { background: rgba(10, 10, 10, 0.6); backdrop-filter: blur(5px); border: 1px solid rgba(57, 255, 20, 0.3); border-radius: 15px; padding: 20px; margin-bottom: 20px; }
        
        .btn { background: linear-gradient(45deg, var(--neon-green), #006400); color: #000; width: 100%; padding: 16px; border: none; border-radius: 4px; font-size: 22px; font-weight: 800; font-family: 'Rubik Glitch', sans-serif; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; box-shadow: 0 0 15px rgba(57, 255, 20, 0.4); margin-bottom: 10px; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); }
        .btn:active { transform: scale(0.98); background: var(--neon-green); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- EDITOR SCREEN --- */
        #editor-wrapper {
            flex: 1;
            position: relative;
            background: #000;
            border: 2px solid var(--neon-green);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.1);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* New Toolbar */
        .toolbar-main {
            display: flex; gap: 10px; justify-content: space-between; margin-bottom: 10px;
        }
        .tool-btn {
            background: rgba(20, 20, 20, 0.9); border: 1px solid #444; color: #fff;
            padding: 12px; border-radius: 8px; font-family: 'Share Tech Mono'; font-size: 12px;
            flex: 1; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .tool-btn i { font-size: 18px; color: var(--neon-green); }
        .tool-btn:active { background: #333; border-color: var(--neon-green); }
        
        .zoom-controls {
            position: absolute; bottom: 15px; right: 15px; display: flex; flex-direction: column; gap: 8px;
        }
        .zoom-circle {
            width: 45px; height: 45px; border-radius: 50%; background: rgba(0,0,0,0.8); border: 2px solid var(--neon-green);
            color: var(--neon-green); font-size: 20px; display: flex; align-items: center; justify-content: center;
        }

        /* --- TUTORIAL OVERLAY --- */
        #tutorial-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 500;
            display: none; justify-content: center; align-items: center; flex-direction: column; text-align: center;
            backdrop-filter: blur(5px);
        }
        .tut-card {
            background: #111; border: 1px solid var(--neon-green); padding: 30px; border-radius: 15px; width: 80%;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.2);
        }
        .tut-row { display: flex; align-items: center; margin-bottom: 20px; text-align: left; }
        .tut-icon { font-size: 30px; width: 50px; text-align: center; margin-right: 15px; }
        
        /* --- LOADING OVERLAY --- */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        .loading-text { font-family: 'Rubik Glitch'; color: var(--neon-green); font-size: 24px; margin-top: 20px; }
        .scanner-beam { width: 250px; height: 2px; background: var(--neon-green); animation: scan-beam 1.5s infinite linear; box-shadow: 0 0 10px var(--neon-green); }
        @keyframes scan-beam { 0% { transform: translateY(-50px); opacity:0; } 50% { opacity:1; } 100% { transform: translateY(50px); opacity:0; } }
        
        #manual-options { display: none; width: 80%; text-align: center; margin-top: 20px; }
        .btn-manual { background: transparent; border: 1px solid var(--neon-orange); color: var(--neon-orange); padding: 10px; width: 100%; margin-top: 10px; }

    </style>
</head>
<body>

    <div class="scanlines"></div>
    <div class="trippy-bg"></div>
    <div class="grid-bg"></div>
    
    <div id="loading-overlay">
        <i class="fas fa-eye" style="font-size: 50px; color: #333;"></i>
        <div class="scanner-beam"></div>
        <div class="loading-text" id="loading-msg">ANALYZING...</div>
        <div id="manual-options">
            <button class="btn btn-manual" onclick="forceEditor()">SKIP AI CHECK</button>
        </div>
    </div>

    <div class="app-container">
        
        <div id="screen-landing" class="screen active">
            <div class="header">
                <i class="fas fa-cannabis logo-icon"></i>
                <div class="brand-name">STONEY<br>BALONEY</div>
                <div class="chill-text">// SECURE_VERIFY_V5</div>
            </div>
            <div style="flex:1; display:flex; align-items:center;">
                <div class="card" style="width:100%;">
                    <div class="feature-row"><i class="fas fa-search"></i><div><h3 style="color:var(--neon-green);">Smart Scan</h3><p style="color:#aaa;">Auto-detects ID.</p></div></div>
                    <div class="feature-row"><i class="fas fa-hand-pointer"></i><div><h3 style="color:var(--neon-purple);">Easy Edit</h3><p style="color:#aaa;">Zoom & Redact easily.</p></div></div>
                </div>
            </div>
            <button class="btn" onclick="goToScreen('screen-select')">START</button>
        </div>

        <div id="screen-select" class="screen">
            <div class="header">
                <h2 style="font-family:'Rubik Glitch'; color:#fff;">UPLOAD ID</h2>
            </div>
            <div style="flex:1; display:flex; flex-direction:column; justify-content:center;">
                <div class="grid">
                    <div class="option" onclick="triggerUpload()"><i class="far fa-id-card"></i><div>ID CARD</div></div>
                    <div class="option" onclick="triggerUpload()"><i class="fas fa-passport"></i><div>PASSPORT</div></div>
                </div>
            </div>
            <input type="file" id="fileInput" accept="image/*" onchange="handleImage(this)" style="display:none;">
        </div>

        <div id="screen-edit" class="screen">
            <div style="text-align:center; margin-bottom: 5px;">
                <span style="color:var(--neon-green); font-family:'Share Tech Mono';">SECURE EDITOR ACTIVE</span>
            </div>

            <div id="editor-wrapper">
                <canvas id="canvas"></canvas>
                
                <div id="tutorial-overlay" onclick="closeTutorial()">
                    <div class="tut-card">
                        <h3 style="color:#fff; margin-bottom:20px;">HOW TO EDIT</h3>
                        <div class="tut-row">
                            <div class="tut-icon">üëÜ</div>
                            <div><strong style="color:var(--neon-green)">ONE FINGER</strong><br><span style="color:#aaa; font-size:12px;">Draw black lines</span></div>
                        </div>
                        <div class="tut-row">
                            <div class="tut-icon">‚úåÔ∏è</div>
                            <div><strong style="color:var(--neon-purple)">TWO FINGERS</strong><br><span style="color:#aaa; font-size:12px;">Pinch to Zoom & Move</span></div>
                        </div>
                        <button class="btn" style="font-size:16px; padding:10px;">GOT IT</button>
                    </div>
                </div>

                <div class="zoom-controls">
                    <div class="zoom-circle" onclick="zoomIn()"><i class="fas fa-plus"></i></div>
                    <div class="zoom-circle" onclick="zoomOut()"><i class="fas fa-minus"></i></div>
                </div>
            </div>

            <div class="toolbar-main">
                <div class="tool-btn" onclick="rotateImage()">
                    <i class="fas fa-redo"></i>
                    <span>ROTATE</span>
                </div>
                <div class="tool-btn" onclick="undoLast()">
                    <i class="fas fa-undo"></i>
                    <span>UNDO</span>
                </div>
                <div class="tool-btn" onclick="resetCanvas()">
                    <i class="fas fa-trash"></i>
                    <span>CLEAR</span>
                </div>
            </div>

            <button id="submitBtn" class="btn" onclick="finishVerification()">UPLOAD SECURELY</button>
        </div>

        <div id="screen-success" class="screen" style="justify-content:center; align-items:center; text-align:center;">
            <i class="fas fa-check-circle" style="font-size: 80px; color: var(--neon-green); margin-bottom:20px;"></i>
            <h1 style="font-family:'Rubik Glitch';">SENT!</h1>
            <p id="success-msg" style="color:#aaa;">Verification Pending...</p>
            <button class="btn" onclick="location.reload()" style="margin-top:40px; background:transparent; border:1px solid #333;">NEW UPLOAD</button>
        </div>
    </div>

    <script>
        // CONFIG
        const WEBHOOK_URL = "YOUR_DISCORD_WEBHOOK_URL_HERE"; 

        // STATE
        let img = new Image();
        let strokes = []; // {x, y} array of lines. Stored in IMAGE COORDINATES.
        let currentStroke = [];
        let view = { x: 0, y: 0, scale: 1 }; // Camera
        let isDrawing = false;
        let isPinching = false;
        let lastTouch = { x:0, y:0 };
        let lastDist = 0;
        
        let aiResult = "SKIPPED";
        let faceModel = null;
        let scanTimer = null;

        // --- INIT ---
        window.onload = async () => {
            try { faceModel = await blazeface.load(); console.log("AI Ready"); } 
            catch(e) { console.log("AI Failed"); }
        };

        function goToScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        // --- UPLOAD & AI FLOW ---
        function triggerUpload() { document.getElementById('fileInput').click(); }

        function handleImage(input) {
            if (!input.files[0]) return;
            const file = input.files[0];
            
            // UI Reset
            document.getElementById('loading-overlay').style.display = 'flex';
            document.getElementById('manual-options').style.display = 'none';
            document.getElementById('loading-msg').innerText = "SCANNING...";
            
            // Failsafe Timer
            scanTimer = setTimeout(() => {
                document.getElementById('manual-options').style.display = 'block';
                document.getElementById('loading-msg').innerText = "AI STUCK?";
            }, 3500);

            const url = URL.createObjectURL(file);
            img.onload = () => {
                // Resize for AI
                const aiCan = document.createElement('canvas');
                const scale = Math.min(1, 400 / img.width);
                aiCan.width = img.width * scale;
                aiCan.height = img.height * scale;
                aiCan.getContext('2d').drawImage(img, 0,0, aiCan.width, aiCan.height);
                
                runAI(aiCan);
            };
            img.src = url;
        }

        async function runAI(canvasRef) {
            try {
                if(!faceModel) faceModel = await blazeface.load();
                const preds = await faceModel.estimateFaces(canvasRef, false);
                
                if (preds.length > 0) {
                    aiResult = "VERIFIED";
                    forceEditor();
                } else {
                    aiResult = "NOT_DETECTED";
                    if(confirm("No face detected. Is this a valid ID?")) forceEditor();
                    else { location.reload(); }
                }
            } catch(e) {
                aiResult = "SKIPPED";
                forceEditor();
            }
        }

        function forceEditor() {
            clearTimeout(scanTimer);
            document.getElementById('loading-overlay').style.display = 'none';
            goToScreen('screen-edit');
            
            // Reset Editor State
            strokes = [];
            
            // Auto-Fit Image
            const canvas = document.getElementById('canvas');
            const wrapper = document.getElementById('editor-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            
            const ratio = Math.min(canvas.width/img.width, canvas.height/img.height);
            view = {
                scale: ratio * 0.9, // 90% fit so they see edges
                x: (canvas.width - img.width * (ratio*0.9)) / 2,
                y: (canvas.height - img.height * (ratio*0.9)) / 2
            };
            
            // Show Tutorial
            document.getElementById('tutorial-overlay').style.display = 'flex';
            
            render();
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
        }

        // --- RENDER ENGINE (The Magic Part) ---
        function render() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // 1. Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            
            // 2. Apply Camera Transform
            ctx.translate(view.x, view.y);
            ctx.scale(view.scale, view.scale);
            
            // 3. Draw Image
            ctx.drawImage(img, 0, 0);
            
            // 4. Draw Strokes (They live in Image Coordinates)
            ctx.lineWidth = 40 / view.scale; // Keep line width constant relative to screen
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#000';

            // Existing strokes
            strokes.forEach(stroke => {
                if(stroke.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for(let i=1; i<stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
                ctx.stroke();
            });

            // Current stroke
            if(currentStroke.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
                for(let i=1; i<currentStroke.length; i++) ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
                ctx.stroke();
            }

            ctx.restore();
        }

        // --- INPUT HANDLING ---
        const canvasEl = document.getElementById('canvas');

        // Helper: Screen Pixel -> Image Coordinate
        function toWorld(tx, ty) {
            return {
                x: (tx - view.x) / view.scale,
                y: (ty - view.y) / view.scale
            };
        }

        canvasEl.addEventListener('touchstart', e => {
            e.preventDefault();
            if(e.touches.length === 2) {
                isPinching = true;
                lastDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                // Center of pinch for panning
                lastTouch = {
                    x: (e.touches[0].clientX + e.touches[1].clientX)/2,
                    y: (e.touches[0].clientY + e.touches[1].clientY)/2
                };
            } else {
                isDrawing = true;
                const t = e.touches[0];
                const rect = canvasEl.getBoundingClientRect();
                const pt = toWorld(t.clientX - rect.left, t.clientY - rect.top);
                currentStroke = [pt];
            }
        }, {passive:false});

        canvasEl.addEventListener('touchmove', e => {
            e.preventDefault();
            if(isPinching && e.touches.length === 2) {
                // Zoom/Pan Logic
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const cx = (e.touches[0].clientX + e.touches[1].clientX)/2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY)/2;
                
                // Pan
                view.x += (cx - lastTouch.x);
                view.y += (cy - lastTouch.y);
                lastTouch = {x:cx, y:cy};

                // Zoom (Simple center zoom)
                const delta = dist - lastDist;
                const zoomFactor = 1 + (delta * 0.005);
                view.scale *= zoomFactor;
                lastDist = dist;
                
                render();
            } else if (isDrawing) {
                const t = e.touches[0];
                const rect = canvasEl.getBoundingClientRect();
                const pt = toWorld(t.clientX - rect.left, t.clientY - rect.top);
                currentStroke.push(pt);
                render();
            }
        }, {passive:false});

        canvasEl.addEventListener('touchend', () => {
            if(isDrawing) {
                strokes.push(currentStroke);
                currentStroke = [];
            }
            isDrawing = false;
            isPinching = false;
            render();
        });

        // --- BUTTONS ---
        function zoomIn() { view.scale *= 1.2; render(); }
        function zoomOut() { view.scale *= 0.8; render(); }
        function rotateImage() {
            // Hard rotation: We actually rotate the VIEW, or reset?
            // Simple approach: Rotate data 90 deg. 
            // For stability in this version, we will just alert 'Rotate on phone first' or implement complex canvas rotation.
            // Let's implement View Rotation (Visual only)
            alert("Tip: Edit the photo in your gallery to rotate before uploading!");
        }
        function undoLast() { strokes.pop(); render(); }
        function resetCanvas() { strokes = []; render(); }

        // --- SUBMIT ---
        function finishVerification() {
            const btn = document.getElementById('submitBtn');
            btn.innerHTML = "ENCRYPTING...";
            btn.disabled = true;

            // Render final high-res output
            const outCan = document.createElement('canvas');
            outCan.width = img.width;
            outCan.height = img.height;
            const ctx = outCan.getContext('2d');
            
            // Draw pure image
            ctx.drawImage(img, 0, 0);
            
            // Draw lines (scaled to full resolution)
            ctx.lineWidth = 40; // thick black line
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#000';
            
            strokes.forEach(stroke => {
                if(stroke.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for(let i=1; i<stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
                ctx.stroke();
            });

            // Upload
            outCan.toBlob(blob => {
                const form = new FormData();
                form.append('file', blob, 'stoney_verify.png');
                form.append('content', `üåø **Verification Request**\n> Status: ${aiResult}`);
                
                fetch(WEBHOOK_URL, {method:'POST', body:form})
                .then(res => {
                    if(res.ok) goToScreen('screen-success');
                    else { alert("Webhook Error"); btn.disabled=false; btn.innerHTML="UPLOAD SECURELY"; }
                });
            });
        }
    </script>
</body>
</html>
