<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stoney Baloney Verify</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Rubik+Glitch&family=Fredoka:wght@400;600&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

    <style>
        :root {
            --neon-green: #39ff14;
            --neon-red: #ff3333;
            --neon-orange: #ffaa00;
            --neon-purple: #bc13fe;
            --deep-space: #050505;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }

        body {
            background-color: var(--deep-space); color: #fff; font-family: 'Fredoka', sans-serif;
            min-height: 100dvh; display: flex; flex-direction: column; overflow: hidden; position: relative; touch-action: none;
        }

        /* --- VISUAL FX --- */
        .trippy-bg { position: fixed; top: 0; left: 0; width: 200%; height: 200%; background: radial-gradient(circle, #1a0b2e 10%, #000000 90%); z-index: -3; animation: breathe 10s infinite alternate; }
        .grid-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(57, 255, 20, 0.15) 1px, transparent 1px), linear-gradient(90deg, rgba(57, 255, 20, 0.15) 1px, transparent 1px); background-size: 40px 40px; perspective: 500px; z-index: -2; opacity: 0.5; mask-image: radial-gradient(circle, black 40%, transparent 80%); }
        .scanlines { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 999; }

        /* --- LAYOUT --- */
        .app-container { flex: 1; display: flex; flex-direction: column; width: 100%; max-width: 500px; margin: 0 auto; padding: 15px; z-index: 10; position: relative; }
        .header { text-align: center; margin-bottom: 20px; margin-top: 10px; }
        .logo-icon { font-size: 60px; color: var(--neon-green); filter: drop-shadow(0 0 15px var(--neon-green)); animation: float 3s ease-in-out infinite; }
        .brand-name { font-family: 'Rubik Glitch', cursive; font-size: 38px; color: #fff; text-shadow: 2px 2px 0px var(--neon-purple); margin-top: 5px; line-height: 1; }
        .chill-text { color: #ccc; font-size: 13px; margin-top: 8px; font-family: 'Share Tech Mono', monospace; letter-spacing: 1px; }

        /* --- SCREENS --- */
        .screen { display: none; flex-direction: column; flex: 1; height: 100%; }
        .screen.active { display: flex; animation: fade-in 0.4s ease; }
        @keyframes fade-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes breathe { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }

        /* --- SELECT SCREEN --- */
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0; }
        .option { background: rgba(0,0,0,0.4); border: 2px solid #333; border-radius: 10px; padding: 25px 10px; text-align: center; transition: 0.2s; }
        .option:active { border-color: var(--neon-green); background: rgba(57, 255, 20, 0.15); box-shadow: 0 0 15px var(--neon-green); }
        .option i { font-size: 32px; color: #fff; margin-bottom: 10px; }
        
        .btn { background: linear-gradient(45deg, var(--neon-green), #006400); color: #000; width: 100%; padding: 16px; border: none; border-radius: 4px; font-size: 22px; font-weight: 800; font-family: 'Rubik Glitch', sans-serif; letter-spacing: 2px; text-transform: uppercase; cursor: pointer; box-shadow: 0 0 15px rgba(57, 255, 20, 0.4); margin-bottom: 10px; }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- EDITOR SCREEN --- */
        #editor-wrapper {
            flex: 1; position: relative; background: #000; border: 2px solid var(--neon-green); border-radius: 10px; overflow: hidden; margin-bottom: 10px; box-shadow: 0 0 20px rgba(57, 255, 20, 0.1);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* Toolbar */
        .toolbar-main { display: flex; gap: 8px; justify-content: space-between; margin-bottom: 10px; flex-wrap:wrap; }
        .tool-btn {
            background: rgba(20, 20, 20, 0.9); border: 1px solid #444; color: #fff; padding: 10px; border-radius: 8px; font-family: 'Share Tech Mono'; font-size: 11px; flex: 1; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 5px; min-width: 50px;
        }
        .tool-btn i { font-size: 16px; color: var(--neon-green); }
        .tool-btn.active { border-color: var(--neon-green); background: rgba(57, 255, 20, 0.1); }
        
        .zoom-controls { position: absolute; bottom: 15px; right: 15px; display: flex; flex-direction: column; gap: 8px; z-index: 100; }
        .zoom-circle { width: 40px; height: 40px; border-radius: 50%; background: rgba(0,0,0,0.8); border: 1px solid var(--neon-green); color: var(--neon-green); font-size: 18px; display: flex; align-items: center; justify-content: center; cursor: pointer;}

        /* --- TUTORIAL OVERLAY --- */
        #tutorial-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 500; display: none; justify-content: center; align-items: center; flex-direction: column; text-align: center;
        }
        .tut-card { background: #111; border: 1px solid var(--neon-green); padding: 25px; border-radius: 15px; width: 85%; }
        .tut-row { display: flex; align-items: center; margin-bottom: 15px; text-align: left; }
        .tut-icon { font-size: 24px; width: 40px; text-align: center; margin-right: 10px; }
        
        /* --- LOADING OVERLAY --- */
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 2000; display: none; justify-content: center; align-items: center; flex-direction: column; }
        .loading-text { font-family: 'Rubik Glitch'; color: var(--neon-green); font-size: 24px; margin-top: 20px; }
        
        #manual-options { display: none; width: 80%; text-align: center; margin-top: 20px; }
        .btn-manual { background: transparent; border: 1px solid var(--neon-orange); color: var(--neon-orange); padding: 10px; width: 100%; margin-top: 10px; }

    </style>
</head>
<body>

    <div class="scanlines"></div>
    <div class="trippy-bg"></div>
    <div class="grid-bg"></div>
    
    <div id="loading-overlay">
        <i class="fas fa-eye" style="font-size: 50px; color: #333;"></i>
        <div class="loading-text" id="loading-msg">ANALYZING...</div>
        <div id="manual-options">
            <button class="btn btn-manual" onclick="forceEditor()">SKIP AI CHECK</button>
        </div>
    </div>

    <div class="app-container">
        
        <div id="screen-landing" class="screen active">
            <div class="header">
                <i class="fas fa-cannabis logo-icon"></i>
                <div class="brand-name">STONEY<br>BALONEY</div>
                <div class="chill-text">// SECURE_VERIFY_V6_PRO</div>
            </div>
            <div style="flex:1; display:flex; align-items:center; justify-content:center;">
                <p style="text-align:center; color:#aaa; max-width:80%;">
                    Secure, Client-Side Redaction.<br>No Server Storage.<br>Total Privacy.
                </p>
            </div>
            <button class="btn" onclick="goToScreen('screen-select')">START VERIFICATION</button>
        </div>

        <div id="screen-select" class="screen">
            <div class="header"><h2 style="font-family:'Rubik Glitch'; color:#fff;">UPLOAD ID</h2></div>
            <div style="flex:1; display:flex; flex-direction:column; justify-content:center;">
                <div class="grid">
                    <div class="option" onclick="triggerUpload()"><i class="far fa-id-card"></i><div>ID CARD</div></div>
                    <div class="option" onclick="triggerUpload()"><i class="fas fa-passport"></i><div>PASSPORT</div></div>
                </div>
            </div>
            <input type="file" id="fileInput" accept="image/*" onchange="handleImage(this)" style="display:none;">
        </div>

        <div id="screen-edit" class="screen">
            <div style="text-align:center; margin-bottom: 5px;">
                <span style="color:var(--neon-green); font-family:'Share Tech Mono';">HD EDITOR ACTIVE</span>
            </div>

            <div id="editor-wrapper">
                <canvas id="canvas"></canvas>
                
                <div id="tutorial-overlay" onclick="closeTutorial()">
                    <div class="tut-card">
                        <h3 style="color:#fff; margin-bottom:15px;">CONTROLS</h3>
                        <div class="tut-row">
                            <div class="tut-icon">üëÜ</div>
                            <div><strong style="color:var(--neon-green)">ONE FINGER</strong><br><span style="color:#aaa; font-size:12px;">Draw to Redact</span></div>
                        </div>
                        <div class="tut-row">
                            <div class="tut-icon">‚úåÔ∏è</div>
                            <div><strong style="color:var(--neon-purple)">TWO FINGERS</strong><br><span style="color:#aaa; font-size:12px;">Pinch to Zoom & Pan</span></div>
                        </div>
                        <div class="tut-row">
                            <div class="tut-icon">üí°</div>
                            <div><span style="color:#aaa; font-size:12px;">Use Zoom (+/-) for precision.</span></div>
                        </div>
                        <button class="btn" style="font-size:14px; padding:10px;">I UNDERSTAND</button>
                    </div>
                </div>

                <div class="zoom-controls">
                    <div class="zoom-circle" onclick="zoomIn()"><i class="fas fa-plus"></i></div>
                    <div class="zoom-circle" onclick="zoomOut()"><i class="fas fa-minus"></i></div>
                </div>
            </div>

            <div class="toolbar-main">
                <div class="tool-btn size-btn" onclick="setBrushSize(10, this)">
                    <div style="width:4px; height:4px; background:currentColor; border-radius:50%;"></div>
                    <span>SMALL</span>
                </div>
                <div class="tool-btn size-btn active" onclick="setBrushSize(25, this)">
                    <div style="width:8px; height:8px; background:currentColor; border-radius:50%;"></div>
                    <span>MED</span>
                </div>
                <div class="tool-btn size-btn" onclick="setBrushSize(50, this)">
                    <div style="width:14px; height:14px; background:currentColor; border-radius:50%;"></div>
                    <span>LARGE</span>
                </div>
                <div class="tool-btn" onclick="undoLast()">
                    <i class="fas fa-undo"></i><span>UNDO</span>
                </div>
            </div>

            <button id="submitBtn" class="btn" onclick="finishVerification()">UPLOAD SECURELY</button>
        </div>

        <div id="screen-success" class="screen" style="justify-content:center; align-items:center; text-align:center;">
            <i class="fas fa-check-circle" style="font-size: 80px; color: var(--neon-green); margin-bottom:20px;"></i>
            <h1 style="font-family:'Rubik Glitch';">SENT!</h1>
            <p id="success-msg" style="color:#aaa;">Verification Pending...</p>
            <button class="btn" onclick="location.reload()" style="margin-top:40px; background:transparent; border:1px solid #333;">NEW UPLOAD</button>
        </div>
    </div>

    <script>
        // CONFIG
        const WEBHOOK_URL = "YOUR_DISCORD_WEBHOOK_URL_HERE"; 

        // STATE
        let img = new Image();
        let strokes = []; 
        let currentStroke = [];
        let view = { x: 0, y: 0, scale: 1 };
        let isDrawing = false;
        let isPinching = false;
        let lastPinchDist = 0;
        let lastTouch = {x:0, y:0};
        
        // Settings
        let brushSize = 25; 
        let aiResult = "SKIPPED";
        let faceModel = null;
        let scanTimer = null;
        let drawTimeout = null; // Fix for accidental dots

        // INIT
        window.onload = async () => {
            try { faceModel = await blazeface.load(); console.log("AI Ready"); } 
            catch(e) { console.log("AI Failed"); }
        };

        function goToScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        // --- UPLOAD FLOW ---
        function triggerUpload() { document.getElementById('fileInput').click(); }

        function handleImage(input) {
            if (!input.files[0]) return;
            const file = input.files[0];
            
            document.getElementById('loading-overlay').style.display = 'flex';
            document.getElementById('manual-options').style.display = 'none';
            document.getElementById('loading-msg').innerText = "SCANNING...";
            
            scanTimer = setTimeout(() => {
                document.getElementById('manual-options').style.display = 'block';
                document.getElementById('loading-msg').innerText = "AI STUCK?";
            }, 3500);

            const url = URL.createObjectURL(file);
            img.onload = () => {
                // Resize for AI (Thumbnail)
                const aiCan = document.createElement('canvas');
                const scale = Math.min(1, 400 / img.width);
                aiCan.width = img.width * scale;
                aiCan.height = img.height * scale;
                aiCan.getContext('2d').drawImage(img, 0,0, aiCan.width, aiCan.height);
                runAI(aiCan);
            };
            img.src = url;
        }

        async function runAI(canvasRef) {
            try {
                if(!faceModel) faceModel = await blazeface.load();
                const preds = await faceModel.estimateFaces(canvasRef, false);
                if (preds.length > 0) {
                    aiResult = "VERIFIED";
                    forceEditor();
                } else {
                    aiResult = "NOT_DETECTED";
                    if(confirm("No face detected. Is this a valid ID?")) forceEditor();
                    else { location.reload(); }
                }
            } catch(e) {
                aiResult = "SKIPPED";
                forceEditor();
            }
        }

        function forceEditor() {
            clearTimeout(scanTimer);
            document.getElementById('loading-overlay').style.display = 'none';
            goToScreen('screen-edit');
            
            strokes = [];
            initEditorCanvas();
            document.getElementById('tutorial-overlay').style.display = 'flex';
        }

        function closeTutorial() {
            document.getElementById('tutorial-overlay').style.display = 'none';
        }

        // --- RETINA SHARP RENDERER ---
        function initEditorCanvas() {
            const canvas = document.getElementById('canvas');
            const wrapper = document.getElementById('editor-wrapper');
            
            // Set resolution to Device Pixel Ratio (Retina)
            const dpr = window.devicePixelRatio || 1;
            canvas.width = wrapper.clientWidth * dpr;
            canvas.height = wrapper.clientHeight * dpr;
            
            // Initial view: Fit Image
            const ratio = Math.min(canvas.width/img.width, canvas.height/img.height);
            view = {
                scale: ratio * 0.95, 
                x: (canvas.width - img.width * (ratio*0.95)) / 2,
                y: (canvas.height - img.height * (ratio*0.95)) / 2
            };
            render();
        }

        function render() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear & Black BG
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#000';
            ctx.fillRect(0,0, canvas.width, canvas.height);
            
            ctx.save();
            // Apply Camera
            ctx.translate(view.x, view.y);
            ctx.scale(view.scale, view.scale);
            
            // Draw Image (High Quality)
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.drawImage(img, 0, 0);
            
            // Draw Strokes
            // Line width must scale inversely to view scale to stay constant on screen
            ctx.lineWidth = brushSize / view.scale * (window.devicePixelRatio || 1); 
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#000';

            [...strokes, currentStroke].forEach(stroke => {
                if(stroke.length < 1) return;
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for(let i=1; i<stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
                ctx.stroke();
            });

            ctx.restore();
        }

        // --- INPUT HANDLING (With Gesture Guard) ---
        const canvasEl = document.getElementById('canvas');

        function toWorld(tx, ty) {
            const dpr = window.devicePixelRatio || 1;
            return {
                x: (tx * dpr - view.x) / view.scale,
                y: (ty * dpr - view.y) / view.scale
            };
        }

        canvasEl.addEventListener('touchstart', e => {
            e.preventDefault();
            
            if(e.touches.length === 2) {
                // PINCH START
                isPinching = true;
                isDrawing = false;
                clearTimeout(drawTimeout); // Kill any pending drawing start
                currentStroke = []; // Clear accidental dots
                lastPinchDist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                lastTouch = {
                    x: (e.touches[0].clientX + e.touches[1].clientX)/2,
                    y: (e.touches[0].clientY + e.touches[1].clientY)/2
                };
            } else if (e.touches.length === 1) {
                // POTENTIAL DRAW START (Wait 50ms to ensure it's not a pinch)
                const t = e.touches[0];
                const rect = canvasEl.getBoundingClientRect();
                const pt = toWorld(t.clientX - rect.left, t.clientY - rect.top);
                
                // Start tracking, but don't set isDrawing yet
                currentStroke = [pt]; 
                
                drawTimeout = setTimeout(() => {
                    if(!isPinching) isDrawing = true;
                }, 70); 
            }
        }, {passive:false});

        canvasEl.addEventListener('touchmove', e => {
            e.preventDefault();
            if(isPinching && e.touches.length === 2) {
                // ZOOM/PAN
                const dist = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const cx = (e.touches[0].clientX + e.touches[1].clientX)/2;
                const cy = (e.touches[0].clientY + e.touches[1].clientY)/2;
                
                // Pan (account for DPR)
                const dpr = window.devicePixelRatio || 1;
                view.x += (cx - lastTouch.x) * dpr;
                view.y += (cy - lastTouch.y) * dpr;
                lastTouch = {x:cx, y:cy};

                // Zoom
                const delta = dist - lastPinchDist;
                const zoomFactor = 1 + (delta * 0.005);
                view.scale *= zoomFactor;
                lastPinchDist = dist;
                
                render();
            } else if (isDrawing && e.touches.length === 1) {
                // DRAW
                const t = e.touches[0];
                const rect = canvasEl.getBoundingClientRect();
                const pt = toWorld(t.clientX - rect.left, t.clientY - rect.top);
                currentStroke.push(pt);
                render();
            }
        }, {passive:false});

        canvasEl.addEventListener('touchend', () => {
            if(isDrawing) {
                strokes.push(currentStroke);
            }
            isDrawing = false;
            isPinching = false;
            currentStroke = [];
            clearTimeout(drawTimeout);
            render();
        });

        // --- TOOLS ---
        function zoomIn() { view.scale *= 1.2; render(); }
        function zoomOut() { view.scale *= 0.8; render(); }
        
        function setBrushSize(size, btn) {
            brushSize = size * 2; // Multiplier for better feel
            document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }
        
        function undoLast() { strokes.pop(); render(); }
        function resetCanvas() { strokes = []; render(); }

        // --- SUBMIT ---
        function finishVerification() {
            const btn = document.getElementById('submitBtn');
            btn.innerHTML = "ENCRYPTING...";
            btn.disabled = true;

            // Render Final Output (Full Resolution)
            const outCan = document.createElement('canvas');
            outCan.width = img.width;
            outCan.height = img.height;
            const ctx = outCan.getContext('2d');
            
            ctx.drawImage(img, 0, 0);
            
            // Draw all strokes
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#000';
            
            // Calculate scale ratio between Screen View and Real Image
            // Actually, our strokes ARE in World (Image) coordinates already!
            // So we just draw them 1:1.
            
            // However, we adjusted visual line width based on zoom.
            // For the file, we want a fixed large size.
            ctx.lineWidth = 45; // Thick redaction for the file

            strokes.forEach(stroke => {
                if(stroke.length < 1) return;
                ctx.beginPath();
                ctx.moveTo(stroke[0].x, stroke[0].y);
                for(let i=1; i<stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
                ctx.stroke();
            });

            outCan.toBlob(blob => {
                const form = new FormData();
                form.append('file', blob, 'stoney_verify.png');
                form.append('content', `üåø **Verification Request**\n> Status: ${aiResult}`);
                
                fetch(WEBHOOK_URL, {method:'POST', body:form})
                .then(res => {
                    if(res.ok) goToScreen('screen-success');
                    else { alert("Webhook Error"); btn.disabled=false; btn.innerHTML="UPLOAD SECURELY"; }
                });
            });
        }
    </script>
</body>
</html>
